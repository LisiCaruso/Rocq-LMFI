(**

- tac; tac': applies tac to the goal, generating n subgoals, 
  then applies tac' to each of these subgoals in turn.

- tac || tac': tries to apply tac to the goal; 
  if it fails, applies tac' instead.

- [tac ;[tac1 |. . .|tacn]]: applies tac to the goal which generates n subgoals
  and taci is applied to the i-th subgoal.

- [idtac]: always succeed, leaving the goal unchanged.

- [fail]: always fail (useful to implement a tactic saying: 
  "I solve the goal immediatly or I fail" with [tac; fail]. 
  Indeed, if [tac] fails, it fails, if [tac] succeeds producing at least one subgoal, 
  it fails and if [tac] suceeds producing no subgoal, it succeeds. 

- [repeat tac]: repeatedly applies [tac] until it fails. 

- [try]: it behaves like [tac || idtac]. It is often useful to do [tac ; try tac'.]
  Another example is [tac; try (tac'; fail).] this tries applying 
  [tac'] to the subgoals generated by [tac] but only to those which are completely 
  solved by [tac'], leaving the other ones unchanged.

**)

Inductive day :=
  monday | tuesday | wednesday | thursday | friday | saturday | sunday.

Definition next_day (d:day) : day :=
  match d with
  | monday => tuesday
  | tuesday => wednesday
  | wednesday => thursday
  | thursday => friday
  | friday => saturday
  | saturday => sunday
  | sunday => monday
  end.

Definition previous_day (d:day) : day :=
  match d with
  | monday => sunday
  | tuesday => monday
  | wednesday => tuesday
  | thursday => wednesday
  | friday => thursday
  | saturday => friday
  | sunday => saturday
  end.

Lemma next_previous : forall d:day,
  previous_day (next_day d) = d.
Proof.
    intros.
    destruct d.
    reflexivity.
    reflexivity.
    reflexivity.
    reflexivity.
    reflexivity.
    reflexivity.
    reflexivity.
Qed.


Lemma next_previous_withsemicolon : forall d:day,
  previous_day (next_day d) = d.
Proof.
    intros.
    destruct d;reflexivity.
Qed.

Lemma next_previous_withbrackets : forall d:day,
  previous_day (next_day d) = d.
Proof.
    intros.
    destruct d; [reflexivity | reflexivity | reflexivity
                  | reflexivity | reflexivity | reflexivity
                  | reflexivity].
Qed.    

Lemma next_previous_or_else : forall d:day,
  previous_day (next_day d) = d.
Proof.
    intros.
    destruct d; ((idtac "assumption "; assumption) || reflexivity).
Qed.

Require Import Arith.

Lemma assoc_full : forall x y z t u v w:nat, 
(x+(y+z+(t+(u+v))))+w+(x+(y+z+(t+(u+v))))+w 
= (x+y+(z+(t+u)))+(v+w+((x+(y+z+(t+(u+v))))+w)).
Proof.
intros.
rewrite Nat.add_assoc.
repeat rewrite Nat.add_assoc.
reflexivity.
Qed.

(** Good practice:
 - Write tactics that solve specific kinds of goals or fails.
 - Do not depend on the result of a tactic that modifies the goal in a difficult to predict manner.
 - Do not use automatically generated names.
*)

Lemma foo : forall A B C : Prop,  (A /\ B /\ C) \/ C -> C.
Proof.
intros.
destruct H.
destruct H.
destruct H0.
assumption.
assumption.
Qed.

Lemma foo' : forall A B C : Prop,  (A /\ B /\ C) \/ C -> C.
Proof.
intros.
repeat destruct H.
destruct H0.
assumption.
assumption.
Qed.


(** The decompose tactic can perform destruct recursively using automatic naming. *)
Lemma foo'' : forall A B C : Prop,  (A /\ B /\ C) \/ C -> C.
Proof.
intros.
decompose [or and] H.
assumption.
assumption.
Qed.



